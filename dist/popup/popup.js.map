{
  "version": 3,
  "sources": ["../../src/utils.ts", "../../src/popup/popup.ts"],
  "sourcesContent": ["/**\n * Parse view count text into a number\n * Handles formats: \"1,234\", \"5.6 K\", \"1.2 M\"\n */\nexport function parseViews(text: string): number | null {\n  if (!text) return null;\n  \n  const match = text.match(/^([\\d,.]+)\\s*([KkMm])?$/);\n  if (!match) return null;\n  \n  const [, numberStr, suffix] = match;\n  const baseNumber = parseFloat(numberStr.replace(/,/g, ''));\n  \n  if (isNaN(baseNumber)) return null;\n  \n  const multiplier = suffix ? (suffix.toLowerCase() === 'k' ? 1000 : 1000000) : 1;\n  return Math.floor(baseNumber * multiplier);\n}\n\nexport interface Keyword {\n  text: string;\n  color: string;\n  enabled: boolean;\n}\n\n// Predefined colors for keyword highlighting\nexport const KEYWORD_COLORS = [\n  '#FFD700', // Gold\n  '#FF6B6B', // Red\n  '#4ECDC4', // Teal\n  '#45B7D1', // Blue\n  '#96CEB4', // Green\n  '#FFEAA7', // Yellow\n  '#DDA0DD', // Plum\n  '#F39C12', // Orange\n];\n\n/**\n * Get the next available color for a new keyword\n */\nexport function getNextKeywordColor(existingKeywords: Keyword[]): string {\n  const usedColors = existingKeywords.map(k => k.color);\n  const availableColor = KEYWORD_COLORS.find(color => !usedColors.includes(color));\n  return availableColor || KEYWORD_COLORS[0];\n}\n\n/**\n * Highlight keywords in text content of an element\n */\nexport function highlightKeywords(element: HTMLElement, keywords: Keyword[]): void {\n  if (!keywords.length) return;\n  \n  const enabledKeywords = keywords.filter(k => k.enabled);\n  if (!enabledKeywords.length) return;\n  \n  // Walk through text nodes only\n  const walker = document.createTreeWalker(\n    element,\n    NodeFilter.SHOW_TEXT,\n    {\n      acceptNode: (node) => {\n        // Skip if parent is already a highlight or is a link/button\n        const parent = node.parentNode as Element;\n        if (parent && (\n          parent.tagName === 'MARK' ||\n          parent.tagName === 'A' ||\n          parent.tagName === 'BUTTON' ||\n          parent.closest('a, button')\n        )) {\n          return NodeFilter.FILTER_REJECT;\n        }\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }\n  );\n\n  const textNodes: Text[] = [];\n  let node;\n  while (node = walker.nextNode()) {\n    textNodes.push(node as Text);\n  }\n\n  textNodes.forEach(textNode => {\n    let content = textNode.textContent || '';\n    if (!content.trim()) return;\n\n    let hasChanges = false;\n    let newHTML = content;\n\n    enabledKeywords.forEach(keyword => {\n      // Simple case-insensitive whole word matching\n      const regex = new RegExp(`\\\\b(${escapeRegex(keyword.text)})\\\\b`, 'gi');\n      const replacement = `<mark style=\"background-color: ${keyword.color}; padding: 1px 2px; border-radius: 2px;\">$1</mark>`;\n      \n      if (regex.test(newHTML)) {\n        newHTML = newHTML.replace(regex, replacement);\n        hasChanges = true;\n      }\n    });\n\n    if (hasChanges) {\n      const span = document.createElement('span');\n      span.innerHTML = newHTML;\n      textNode.parentNode?.replaceChild(span, textNode);\n    }\n  });\n}\n\n/**\n * Remove all keyword highlights from an element\n */\nexport function removeKeywordHighlights(element: HTMLElement): void {\n  const marks = element.querySelectorAll('mark');\n  marks.forEach(mark => {\n    const textNode = document.createTextNode(mark.textContent || '');\n    mark.parentNode?.replaceChild(textNode, mark);\n  });\n  \n  // Clean up any empty spans created by highlighting\n  const spans = element.querySelectorAll('span:empty');\n  spans.forEach(span => span.remove());\n}\n\n/**\n * Escape special regex characters\n */\nfunction escapeRegex(text: string): string {\n  return text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n} ", "// Popup script for Tweet Heat Map extension\n// Handles the on/off toggle and keyword management\n\nimport { Keyword, getNextKeywordColor } from '../utils.js';\n\ninterface Settings {\n  enabled: boolean;\n}\n\nconst SETTINGS_KEY = 'thm-settings';\nconst KEYWORDS_KEY = 'thm-keywords';\n\n/**\n * Load current settings from chrome.storage\n */\nasync function loadSettings(): Promise<Settings> {\n  try {\n    const result = await chrome.storage.sync.get([SETTINGS_KEY]);\n    return result[SETTINGS_KEY] || { enabled: true };\n  } catch (error) {\n    console.error('Error loading settings:', error);\n    return { enabled: true };\n  }\n}\n\n/**\n * Save settings to chrome.storage\n */\nasync function saveSettings(settings: Settings): Promise<void> {\n  try {\n    await chrome.storage.sync.set({ [SETTINGS_KEY]: settings });\n  } catch (error) {\n    console.error('Error saving settings:', error);\n  }\n}\n\n/**\n * Load keywords from chrome.storage\n */\nasync function loadKeywords(): Promise<Keyword[]> {\n  try {\n    const result = await chrome.storage.sync.get([KEYWORDS_KEY]);\n    return result[KEYWORDS_KEY] || [];\n  } catch (error) {\n    console.error('Error loading keywords:', error);\n    return [];\n  }\n}\n\n/**\n * Save keywords to chrome.storage\n */\nasync function saveKeywords(keywords: Keyword[]): Promise<void> {\n  try {\n    await chrome.storage.sync.set({ [KEYWORDS_KEY]: keywords });\n  } catch (error) {\n    console.error('Error saving keywords:', error);\n  }\n}\n\n/**\n * Update the toggle UI state\n */\nfunction updateToggleUI(enabled: boolean): void {\n  const toggle = document.getElementById('enabled-toggle') as HTMLInputElement;\n  if (toggle) {\n    toggle.checked = enabled;\n  }\n}\n\n/**\n * Handle toggle change\n */\nasync function handleToggleChange(event: Event): Promise<void> {\n  const toggle = event.target as HTMLInputElement;\n  const settings: Settings = {\n    enabled: toggle.checked\n  };\n  \n  await saveSettings(settings);\n  \n  // Update badge icon to reflect state (optional enhancement)\n  try {\n    await chrome.action.setIcon({\n      path: settings.enabled ? 'icons/icon128.png' : 'icons/icon128-disabled.png'\n    });\n  } catch (error) {\n    // Icon change is optional, don't fail if it doesn't work\n    console.debug('Could not update icon:', error);\n  }\n}\n\n/**\n * Render the keyword list in the UI\n */\nfunction renderKeywords(keywords: Keyword[]): void {\n  const keywordList = document.getElementById('keyword-list');\n  if (!keywordList) return;\n  \n  keywordList.innerHTML = '';\n  \n  keywords.forEach((keyword, index) => {\n    const item = document.createElement('div');\n    item.className = 'keyword-item';\n    \n    item.innerHTML = `\n      <span class=\"keyword-text\">${keyword.text}</span>\n      <div class=\"keyword-color\" style=\"background-color: ${keyword.color}\"></div>\n      <button class=\"btn-remove\" data-index=\"${index}\">\u00D7</button>\n    `;\n    \n    keywordList.appendChild(item);\n  });\n}\n\n/**\n * Add a new keyword\n */\nasync function addKeyword(text: string): Promise<void> {\n  const trimmedText = text.trim().toLowerCase();\n  if (!trimmedText) return;\n  \n  const keywords = await loadKeywords();\n  \n  // Check if keyword already exists\n  if (keywords.some(k => k.text.toLowerCase() === trimmedText)) {\n    return;\n  }\n  \n  const newKeyword: Keyword = {\n    text: trimmedText,\n    color: getNextKeywordColor(keywords),\n    enabled: true\n  };\n  \n  keywords.push(newKeyword);\n  await saveKeywords(keywords);\n  renderKeywords(keywords);\n}\n\n/**\n * Remove a keyword by index\n */\nasync function removeKeyword(index: number): Promise<void> {\n  const keywords = await loadKeywords();\n  keywords.splice(index, 1);\n  await saveKeywords(keywords);\n  renderKeywords(keywords);\n}\n\n/**\n * Handle keyword input form submission\n */\nasync function handleKeywordSubmit(): Promise<void> {\n  const input = document.getElementById('keyword-input') as HTMLInputElement;\n  if (!input) return;\n  \n  await addKeyword(input.value);\n  input.value = '';\n}\n\n/**\n * Set up keyword management event listeners\n */\nfunction setupKeywordListeners(): void {\n  // Add keyword button\n  const addBtn = document.getElementById('add-keyword');\n  if (addBtn) {\n    addBtn.addEventListener('click', handleKeywordSubmit);\n  }\n  \n  // Enter key in input\n  const input = document.getElementById('keyword-input') as HTMLInputElement;\n  if (input) {\n    input.addEventListener('keydown', (e) => {\n      if (e.key === 'Enter') {\n        e.preventDefault();\n        handleKeywordSubmit();\n      }\n    });\n  }\n  \n  // Remove keyword buttons (delegated)\n  const keywordList = document.getElementById('keyword-list');\n  if (keywordList) {\n    keywordList.addEventListener('click', async (e) => {\n      const target = e.target as HTMLElement;\n      if (target.classList.contains('btn-remove')) {\n        const index = parseInt(target.getAttribute('data-index') || '0');\n        await removeKeyword(index);\n      }\n    });\n  }\n}\n\n/**\n * Initialize the popup\n */\nasync function initPopup(): Promise<void> {\n  try {\n    // Load current settings and keywords\n    const settings = await loadSettings();\n    const keywords = await loadKeywords();\n    \n    // Update UI\n    updateToggleUI(settings.enabled);\n    renderKeywords(keywords);\n    \n    // Set up toggle listener\n    const toggle = document.getElementById('enabled-toggle') as HTMLInputElement;\n    if (toggle) {\n      toggle.addEventListener('change', handleToggleChange);\n    }\n    \n    // Set up keyword management\n    setupKeywordListeners();\n    \n    console.debug('Popup initialized');\n  } catch (error) {\n    console.error('Error initializing popup:', error);\n  }\n}\n\n// Initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', initPopup);\n} else {\n  initPopup();\n} "],
  "mappings": "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",
  "names": []
}
